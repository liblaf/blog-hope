import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as t,o as a}from"./app-BMihMyie.js";const r={};function n(o,e){return a(),s("div",null,[...e[0]||(e[0]=[t(`<div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;linux/fs.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> file { ... };</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="f-mode" tabindex="-1"><a class="header-anchor" href="#f-mode"><span>f_mode</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">mode_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> f_mode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The file mode identifies the file as either readable or writable (or both), by means of the bits <code>FMODE_READ</code> and <code>FMODE_WRITE</code>. You might want to check this field for read/write permission in your <code>open</code> or <code>ioctl</code> function, but you don’t need to check permissions for <code>read</code> and <code>write</code>, because the kernel checks before invoking your method. An attempt to read or write when the file has not been opened for that type of access is rejected without the driver even knowing about it.</p><h2 id="f-pos" tabindex="-1"><a class="header-anchor" href="#f-pos"><span>f_pos</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">loff_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> f_pos;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The current reading or writing position. <code>loff_t</code> is a 64-bit value on all platforms (<code>long long</code> in <code>gcc</code> terminology). The driver can read this value if it needs to know the current position in the file but should not normally change it; <code>read</code> and <code>write</code> should update a position using the pointer they receive as the last argument instead of acting on <code>filp-&gt;f_pos</code> directly. The one exception to this rule is in the <code>llseek</code> method, the purpose of which is to change the file position.</p><h2 id="f-flags" tabindex="-1"><a class="header-anchor" href="#f-flags"><span>f_flags</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> f_flags;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>These are the file flags, such as <code>O_RDONLY</code>, <code>O_NONBLOCK</code>, and <code>O_SYNC</code>. A driver should check the <code>O_NONBLOCK</code> flag to see if nonblocking operation has been requested (we discuss nonblocking I/O in the section “Blocking and Nonblocking Operations” in Chapter 6); the other flags are seldom used. In particular, read/write permission should be checked using <code>f_mode</code> rather than <code>f_flags</code>. All the flags are defined in the header <code>&lt;linux/fcntl.h&gt;</code>.</p><h2 id="f-op" tabindex="-1"><a class="header-anchor" href="#f-op"><span>f_op</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> file_operations </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">f_op;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The operations associated with the file. The kernel assigns the pointer as part of its implementation of <code>open</code> and then reads it when it needs to dispatch any operations. The value in <code>filp-&gt;f_op</code> is never saved by the kernel for later reference; this means that you can change the file operations associated with your file, and the new methods will be effective after you return to the caller. For example, the code for <code>open</code> associated with major number 1 (<code>/dev/null</code>, <code>/dev/zero</code>, and so on) substitutes the operations in <code>filp-&gt;f_op</code> depending on the minor number being opened. This practice allows the implementation of several behaviors under the same major number without introducing overhead at each system call. The ability to replace the file operations is the kernel equivalent of “method overriding” in object-oriented programming.</p><h2 id="private-data" tabindex="-1"><a class="header-anchor" href="#private-data"><span>private_data</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">private_data;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The <code>open</code> system call sets this pointer to <code>NULL</code> before calling the <code>open</code> method for the driver. You are free to make its own use of the field or to ignore it; you can use the field to point to allocated data, but then you must remember to free that memory in the <code>release</code> method before the <code>file</code> structure is destroyed by the kernel. <code>private_data</code> is a useful resource for preserving state information across system calls and is used by most of our sample modules.</p><h2 id="f-dentry" tabindex="-1"><a class="header-anchor" href="#f-dentry"><span>f_dentry</span></a></h2><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> dentry </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">f_dentry;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The directory entry (<code>dentry</code>) structure associated with the file. Device driver writers normally need not concern themselves with <code>dentry</code> structures, other than to access the <code>inode</code> structure as <code>filp-&gt;f_dentry-&gt;d_inode</code>.</p>`,19)])])}const h=i(r,[["render",n]]),c=JSON.parse('{"path":"/2022/research/notes/linux-device-drivers/2022-05-13-linux-device-drivers-char-drivers-the-file-structure.html","title":"Linux Device Drivers | Char Drivers | The file Structure","lang":"en-US","frontmatter":{"category":["Research"],"date":"2022-05-13T00:00:00.000Z","isOriginal":false,"modified":"2025-09-20T15:07:39.000Z","tags":["C_Cpp","Char_Drivers","Linux","Linux_Device_Drivers","Linux_Kernel"],"title":"Linux Device Drivers | Char Drivers | The file Structure","description":"f_mode The file mode identifies the file as either readable or writable (or both), by means of the bits FMODE_READ and FMODE_WRITE. You might want to check this field for read/w...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux Device Drivers | Char Drivers | The file Structure\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-13T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liblaf\\",\\"url\\":\\"https://github.com/liblaf\\"}]}"],["meta",{"property":"og:url","content":"https://hope.liblaf.me/2022/research/notes/linux-device-drivers/2022-05-13-linux-device-drivers-char-drivers-the-file-structure.html"}],["meta",{"property":"og:site_name","content":"liblaf"}],["meta",{"property":"og:title","content":"Linux Device Drivers | Char Drivers | The file Structure"}],["meta",{"property":"og:description","content":"f_mode The file mode identifies the file as either readable or writable (or both), by means of the bits FMODE_READ and FMODE_WRITE. You might want to check this field for read/w..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"Linux_Kernel"}],["meta",{"property":"article:tag","content":"Linux_Device_Drivers"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:tag","content":"Char_Drivers"}],["meta",{"property":"article:tag","content":"C_Cpp"}],["meta",{"property":"article:published_time","content":"2022-05-13T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":1.88,"words":564},"filePathRelative":"2022/research/notes/linux-device-drivers/2022-05-13-linux-device-drivers-char-drivers-the-file-structure.md","excerpt":"<div class=\\"language-c line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-c\\"><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">#include</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> &lt;linux/fs.h&gt;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">struct</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> file { ... };</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{h as comp,c as data};
