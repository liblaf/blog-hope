import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as r,o}from"./app-BMihMyie.js";const a={};function s(i,e){return o(),n("div",null,[...e[0]||(e[0]=[r('<p>写代码一时爽, 数据管理火葬场. 我是仓鼠, 我时常会陷入一种 “数据焦虑”: 我的代码、我的数据集、我的实验结果… 它们还安全吗? 🤯 万一哪天硬盘暴毙, 服务器被黑, 我会不会一夜回到解放前?</p><p>为了睡个好觉, 我折腾了一些数据存储和备份方案. 它不一定是最优解, 但目前还凑合.</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>本文充斥着我的直觉, 主观臆断和偏执, 请谨慎食用! 如有雷同, 那说明我很棒了.</p></div><h2 id="📁-需求分类" tabindex="-1"><a class="header-anchor" href="#📁-需求分类"><span>📁 需求分类</span></a></h2><p>我的数据体量不算大, 考虑到未来的增长先按 2TB 算.</p><p>我把存储分为三类:</p><ol><li><strong>Daily:</strong> 日常频繁读写的存储</li><li><strong>Archive:</strong> 基本不写入, 但需要时不时读取</li><li><strong>Backup:</strong> 定期写入, 只在数据丢失时才会动用</li></ol><p>至于代码, 它们有最好的归宿 — <a href="https://github.com/" target="_blank" rel="noopener noreferrer">GitHub</a>. 我相信 GitHub 的专业性和安全性, 所以本文的讨论不包含代码.</p><h2 id="🏷-信任鄙视链" tabindex="-1"><a class="header-anchor" href="#🏷-信任鄙视链"><span>🏷 信任鄙视链</span></a></h2><p>我对存储的可靠性有一套自己的 “迷信” 排序, 从高到低大概是这样的:</p><p><strong>企业级服务 &gt; 企业级硬件 + 我自己用 &gt; 消费级硬件 + 我自己用 &gt; 企业级硬件 + 公用 &gt; 消费级硬件 + 公用</strong></p><p>简单说就是: 我相信大公司, 相信我自己, 但不太敢相信别人 (比如公用环境).</p><p>具体来说:</p><ol><li>✅ <strong>100% 可靠 (我认为):</strong><ol><li>企业级服务, 比如 OneDrive, 清华云盘. 微软和清华 ITS, 我放心. 就是容量还不够大.</li></ol></li><li>👍 <strong>比较可靠, 基本不担心:</strong><ol><li><a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program" target="_blank" rel="noopener noreferrer">Microsoft 365 Developer Program</a> 提供的 5TB OneDrive. 虽然续期有可能翻车, 但我相信巨硬的稳定性, 而且到期后仍留有充裕的时间用于转移数据.</li><li>自用的消费级硬件, 比如健康的 SSD, PSSD. 我相信自己, 但也怕哪天脑子一抽误删东西.</li><li>实验室的数据服务器 (RAID6). RAID6 还是靠谱的. 虽然权限管理比较严格, 但我总担心会不会有误操作, 或者被攻击.</li></ol></li><li>🚽 <strong>公厕:</strong><ol><li>实验室的计算服务器. 服务器的用户包括同学们 <s>和匿名黑客</s>. 尽管我是管理员, 但共享环境的可靠性取决于最不靠谱的那个人, 而你永远不知道他是谁 (甚至可能是我自己).</li><li><strong>百度网盘:</strong> What can I say? 🤷</li></ol></li></ol><h3 id="🔁-3-2-1-原则" tabindex="-1"><a class="header-anchor" href="#🔁-3-2-1-原则"><span>🔁 3-2-1 原则</span></a></h3><p>我听闻备份的 “3-2-1 原则” (3 份拷贝, 2 种介质, 1 份异地). 但我是穷学生. 不过这个原则确实值得参考.</p><h2 id="🗂-数据集" tabindex="-1"><a class="header-anchor" href="#🗂-数据集"><span>🗂 数据集</span></a></h2><p>我平时这样处理数据集:</p><ul><li><strong>Daily:</strong> 直接拷贝到项目目录下, 简单粗暴.</li><li><strong>Archive:</strong> 我会用 <code>.tar.zst</code> 格式以最高压缩率狠狠压缩它, 然后扔进清华云盘. 我的 CPU 算力不值钱, 但云盘空间寸土寸金, 必须狠狠地压缩. 同时还会记录压缩文件的哈希值 (我偏爱 blake3) 以备校验.</li></ul><p>因为我相信清华云盘, 所以不再额外 <strong>backup</strong>.</p><h2 id="🔬-实验和中间结果-git-dvc" tabindex="-1"><a class="header-anchor" href="#🔬-实验和中间结果-git-dvc"><span>🔬 实验和中间结果: Git + DVC</span></a></h2><p>这部分是我的得意之作, 它解决了困扰我多年的代码与数据版本同步难题.</p><p>我开发了一个名为 <a href="https://github.com/liblaf/cherries" target="_blank" rel="noopener noreferrer">🍒 Cherries</a> 的 Python 小工具来自动化许多流程. 一次完整的 “experiment run” 大概是这样:</p><ol><li><strong>运行脚本:</strong> 像往常一样 <code>python src/30-compute.py</code>. 我喜欢用数字前缀来命名脚本 (<code>10-gen.py</code>, <code>20-preprocess.py</code>), 这样这样按文件名排序, 依赖关系一目了然.</li><li><strong>Inputs:</strong> 在实验开始前, Cherries 自动调用 <code>dvc add [inputs]</code>, 并启用 <a href="https://www.comet.com/site/" target="_blank" rel="noopener noreferrer">Comet</a> 进行 experiment tracking</li><li><strong>Tracking:</strong> 代码运行时, Comet 会记录 <code>stdout</code> 和 <code>stderr</code>, 方便在网页端查看</li><li><strong>Outputs:</strong> 跑完后, Cherries 再次调用 <code>dvc add [outputs]</code></li><li><strong>Git Commit:</strong> 自动生成 git commit, message 中包含运行参数, inputs + outputs 路径和 Comet URL 等 metadata. 由于 DVC 的存在, 这次 commit 实际上已经锁定了本次实验的完整输入、输出和代码版本.</li><li><strong>Local Snapshots:</strong> Cherries 会把 source code, inputs, outputs, <code>run.log</code> 都拷贝一份到本地的 <code>.cherries/</code> 目录下, 方便快速对比近几次实验的异同.</li></ol><p>这样下来:</p><ul><li><strong>代码与数据存储分离:</strong> 代码 push 到 GitHub, 而数据通过 DVC push 到我自己的存储后端. 我可以公开代码, 同时将数据保密. 除非有外星科技能从 DVC 的 MD5 指针恢复原文件 😉</li><li><strong>版本控制:</strong> <code>git checkout</code> 到任何一个历史 commit, DVC 就会自动拉取对应版本的数据, 复现当时的工作区.</li><li><strong>自动化:</strong> 结合 pre-commit hooks, git push 时 DVC 会自动上传数据, git pull 或 checkout 时会自动下载, 全程无感.</li></ul><p>我选用 <a href="https://dvc.org/doc/user-guide/data-management/remote-storage/ssh" target="_blank" rel="noopener noreferrer">SSH</a> 作为 DVC 远程存储, 数据存在我自己的 PC 上. 美中不足的是, DVC 目前还不支持压缩. 为了保险起见，我还会用 <a href="https://creativeprojects.github.io/resticprofile/index.html" target="_blank" rel="noopener noreferrer">Restic Profile</a> 定时备份数据到清华云盘. <a href="https://restic.readthedocs.io/en/stable/" target="_blank" rel="noopener noreferrer">Restic</a> 真心好用: snapshots 创建和清理都很方便, 支持块级去重和压缩. 我甚至每小时做一次快照. 反正我的 CPU 算理不值钱, 但云盘空间寸土寸金, 必须狠狠地压缩.</p><h3 id="❓-why-not-git-lfs" tabindex="-1"><a class="header-anchor" href="#❓-why-not-git-lfs"><span>❓ Why not Git LFS?</span></a></h3><p>Git LFS 其实是个不错的选择, 但我最终没选它, 原因有二:</p><ol><li><strong>对文件夹支持不优雅:</strong> 如果有一个包含 1000 帧的动画文件夹, Git LFS 会生成 1000 个 pointer, 而 DVC 只需要一个 <code>.dvc</code> 文件.</li><li><strong>需要 self-host service:</strong> GitHub 那点免费额度, 分分钟就用光了. Gitea 用 docker compose 起起来是挺方便的, 几分钟就能上线使用. 但额外维护一个服务也是要花时间的. 而 DVC 可以依赖于 SSH / WebDAV 存储, 我本就需要 SSH 和 WebDAV, 所以没有额外的负担.</li></ol><h2 id="💾-filesystem" tabindex="-1"><a class="header-anchor" href="#💾-filesystem"><span>💾 Filesystem</span></a></h2><p>我参考了 <a href="https://wiki.cachyos.org/installation/filesystem/" target="_blank" rel="noopener noreferrer">Filesystems | CachyOS</a> 和 <a href="https://wiki.archlinux.org/title/File_systems" target="_blank" rel="noopener noreferrer">File systems - ArchWiki</a>, 最终选择了 <strong>Btrfs</strong>.</p><h3 id="why-btrfs" tabindex="-1"><a class="header-anchor" href="#why-btrfs"><span>Why Btrfs?</span></a></h3><p>我尤其喜欢以下这两个功能:</p><h4 id="✅-pros" tabindex="-1"><a class="header-anchor" href="#✅-pros"><span>✅ Pros</span></a></h4><ul><li><strong>Transparent compression.</strong> BTRFS supports transparently compressing files to allow for significant space savings with no user intervention.</li><li><strong>Snapshot functionality.</strong> BTRFS leverages its COW nature to allow for the creation of snapshots of subvolumes that take up very little actual space.</li></ul><p>Btrfs 的 snapshot 非常好用, 配合 <a href="https://github.com/wesbarnett/snap-pac" target="_blank" rel="noopener noreferrer">snap-pac</a> 可以 to perform a pre and post snapshot before and after pacman transactions. 与 <a href="https://gitlab.com/Zesko/limine-snapper-sync" target="_blank" rel="noopener noreferrer">Limine-Snapper-Sync</a> 配合可以直接在 Limine boot manager 界面直接从 snapshot 启动.</p><h4 id="❌-cons" tabindex="-1"><a class="header-anchor" href="#❌-cons"><span>❌ Cons</span></a></h4><ul><li>Worse on rotational drives due to aforementioned fragmentation.</li></ul><p>目前我的所有硬盘都是 SSD, 所以 Btrfs 的 fragmentation 问题对我影响不大. 另外听说 Btrfs 的 RAID 支持有点问题, 但我基本上每台机器只有一块盘, 用不上 RAID.</p><h3 id="🤔-why-not" tabindex="-1"><a class="header-anchor" href="#🤔-why-not"><span>🤔 Why not …?</span></a></h3><h4 id="why-not-ext4" tabindex="-1"><a class="header-anchor" href="#why-not-ext4"><span>Why not ext4?</span></a></h4><p>EXT4 (fourth extended filesystem) is the most commonly used Linux filesystem.</p><h5 id="❌-cons-1" tabindex="-1"><a class="header-anchor" href="#❌-cons-1"><span>❌ Cons</span></a></h5><ul><li>Lacks many of the advanced features other filesystems offer.</li></ul><p>ext4 久经历史考验. 但 ext4 不支持 transparent compression 和 snapshot. 也许我有了 HDD 会用 ext4, 毕竟 HDD 不大可能会拿来做系统盘, 更可能是数据盘, 这时 snapshot functionality 就没那么重要了.</p><h4 id="why-not-zfs" tabindex="-1"><a class="header-anchor" href="#why-not-zfs"><span>Why not ZFS?</span></a></h4><p>ZFS is an advanced filesystem originally developed by Sun Microsystems in 2005. ZFS has many features, but is licensed under CDDL which means it cannot be included inside the linux kernel and requires a separate module installed.</p><h5 id="✅-pros-1" tabindex="-1"><a class="header-anchor" href="#✅-pros-1"><span>✅ Pros</span></a></h5><ul><li>Pooled storage (zpool)</li><li>Snapshots using COW</li><li>Compression</li><li>Raid-Z support</li><li>ARC cache allows insanely fast read times on commonly accessed files.</li></ul><p>ZFS 简直太强大了, 拥有我梦想的所有功能.</p><h5 id="❌-cons-2" tabindex="-1"><a class="header-anchor" href="#❌-cons-2"><span>❌ Cons</span></a></h5><ul><li>Very complicated to use and understand due to features like zpool and ARC.</li><li>ARC requires a lot of ram to be effective.</li><li>Not included in the linux kernel therefore dependent on a third party kernel module (OpenZFS)</li></ul><p>但 ZFS 配置有些复杂, 还有 license 问题. 虽然尝试配置成功了, 但还是害怕维护成本所以放弃了.</p>',54)])])}const c=t(a,[["render",s]]),h=JSON.parse('{"path":"/2025/2025-09-19-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%8A%98%E8%85%BE%E6%89%8B%E8%AE%B0.html","title":"💾 数据存储折腾手记","lang":"en-US","frontmatter":{"date":"2025-09-19T08:00:18.000Z","modified":"2025-09-20T10:38:12.000Z","title":"💾 数据存储折腾手记","description":"写代码一时爽, 数据管理火葬场. 我是仓鼠, 我时常会陷入一种 “数据焦虑”: 我的代码、我的数据集、我的实验结果… 它们还安全吗? 🤯 万一哪天硬盘暴毙, 服务器被黑, 我会不会一夜回到解放前? 为了睡个好觉, 我折腾了一些数据存储和备份方案. 它不一定是最优解, 但目前还凑合. Warning 本文充斥着我的直觉, 主观臆断和偏执, 请谨慎食用!...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"💾 数据存储折腾手记\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-09-19T08:00:18.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liblaf\\",\\"url\\":\\"https://github.com/liblaf\\"}]}"],["meta",{"property":"og:url","content":"https://hope.liblaf.me/2025/2025-09-19-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%8A%98%E8%85%BE%E6%89%8B%E8%AE%B0.html"}],["meta",{"property":"og:site_name","content":"liblaf"}],["meta",{"property":"og:title","content":"💾 数据存储折腾手记"}],["meta",{"property":"og:description","content":"写代码一时爽, 数据管理火葬场. 我是仓鼠, 我时常会陷入一种 “数据焦虑”: 我的代码、我的数据集、我的实验结果… 它们还安全吗? 🤯 万一哪天硬盘暴毙, 服务器被黑, 我会不会一夜回到解放前? 为了睡个好觉, 我折腾了一些数据存储和备份方案. 它不一定是最优解, 但目前还凑合. Warning 本文充斥着我的直觉, 主观臆断和偏执, 请谨慎食用!..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:published_time","content":"2025-09-19T08:00:18.000Z"}]]},"git":{},"readingTime":{"minutes":6.66,"words":1999},"filePathRelative":"2025/2025-09-19-数据存储折腾手记.md","excerpt":"<p>写代码一时爽, 数据管理火葬场. 我是仓鼠, 我时常会陷入一种 “数据焦虑”: 我的代码、我的数据集、我的实验结果… 它们还安全吗? 🤯 万一哪天硬盘暴毙, 服务器被黑, 我会不会一夜回到解放前?</p>\\n<p>为了睡个好觉, 我折腾了一些数据存储和备份方案. 它不一定是最优解, 但目前还凑合.</p>\\n<div class=\\"hint-container warning\\">\\n<p class=\\"hint-container-title\\">Warning</p>\\n<p>本文充斥着我的直觉, 主观臆断和偏执, 请谨慎食用! 如有雷同, 那说明我很棒了.</p>\\n</div>\\n<h2>📁 需求分类</h2>","autoDesc":true}');export{c as comp,h as data};
