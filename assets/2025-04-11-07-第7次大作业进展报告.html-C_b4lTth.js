import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as t}from"./app-BMihMyie.js";const l={};function n(h,i){return t(),a("div",null,[...i[0]||(i[0]=[e(`<h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>请编写带有图形界面的普通三阶魔方模拟程序.</p><p>要求:</p><ul><li>实现平移、放大、缩小和自适应大小的魔方展示功能.</li><li>请自定义编码表示魔方的各种可能操作, 每种编码表示其中 1 种操作.</li><li>实现打开文本文件的功能, 该文本文件由一系列编码组成, 对应魔方操作.</li><li>实现魔方操作功能: 可以交互实现每个操作, 也可以通过动画自动播放魔方的系列操作.</li><li>在操作或转动魔方时, 必须以动画的形式展示, 从而方便看清如何操作或转动.</li><li>可以保存魔方操作, 保存结果是由一系列编码组成文本文件.</li><li>编写文档详细介绍模拟算法与图形界面等内容.</li></ul><p>参考:</p><ul><li>雍俊海. 清华教授的小课堂魔方真好玩. 北京: 清华大学出版社.</li></ul><h2 id="_1-魔方分割方法" tabindex="-1"><a class="header-anchor" href="#_1-魔方分割方法"><span>1. 魔方分割方法</span></a></h2><h3 id="_1-1-三维网格划分体系" tabindex="-1"><a class="header-anchor" href="#_1-1-三维网格划分体系"><span>1.1 三维网格划分体系</span></a></h3><p>本系统采用 <code>3 x 3 x 3</code> 的立体网格对魔方进行空间划分, 将魔方解构为 26 个可见小立方体 (排除中心不可见单元). 每个网格单元使用三维坐标 <code>(x, y, z)</code> 唯一标识, 坐标取值范围为 <code>{0, 1, 2}</code>.</p><h3 id="_1-2-分组命名规则" tabindex="-1"><a class="header-anchor" href="#_1-2-分组命名规则"><span>1.2 分组命名规则</span></a></h3><p>通过 <code>group_name(...)</code> 函数实现坐标到分组名的映射：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> group_name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,  </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,  </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> z</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) -&gt; std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fmt::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">format</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;{}{}{}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,  x,  y,  z);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例: 坐标 (0, 2, 1) 对应分组 “021”</p><h3 id="_1-3-面片归属判定" tabindex="-1"><a class="header-anchor" href="#_1-3-面片归属判定"><span>1.3 面片归属判定</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 几何中心计算: 对每个面片计算包围盒中心坐标</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">glm::vec3 center </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (shape_bound_max </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> shape_bound_min) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2.0</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 网格映射: 将中心坐标映射到 3×3×3 网格</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">glm::ivec3 grid </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> glm::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">floor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((center </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> scene_bound_min) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cube_length);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 动态分组: 根据计算结果将面片加入对应分组</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">polyscope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSurfaceMesh</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">shape</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addToGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-4-面层选择算法" tabindex="-1"><a class="header-anchor" href="#_1-4-面层选择算法"><span>1.4 面层选择算法</span></a></h3><p>通过 <code>select_meshes(...)</code> 函数实现面层选择：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">case</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;f&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 选择前面 (z = 2 平面)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(z </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">groups</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push_back</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">group_name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x, y, z));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>各面层对应条件:</p><ul><li>(F)ront: <code>z == 2</code></li><li>(B)ack: <code>z == 0</code></li><li>(U)p: <code>y == 2</code></li><li>(D)own: <code>y == 0</code></li><li>(L)eft: <code>x == 0</code></li><li>®ight: <code>x == 2</code></li></ul><h2 id="_2-魔方动画实现" tabindex="-1"><a class="header-anchor" href="#_2-魔方动画实现"><span>2. 魔方动画实现</span></a></h2><h3 id="_2-1-核心动画算法" tabindex="-1"><a class="header-anchor" href="#_2-1-核心动画算法"><span>2.1 核心动画算法</span></a></h3><p>旋转轴选择策略:</p><ul><li>F/B 面: 绕 Z 轴</li><li>U/D 面: 绕 Y 轴</li><li>L/R 面: 绕 X 轴</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> callback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  rotation </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0.01</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 每帧增加旋转角度</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  mesh</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setTransform</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">glm</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">rotate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(rotation,  axis));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-动画控制逻辑-todo" tabindex="-1"><a class="header-anchor" href="#_2-2-动画控制逻辑-todo"><span>2.2 动画控制逻辑 (TODO)</span></a></h3><ol><li><strong>状态管理</strong></li><li><strong>动画队列机制</strong></li><li><strong>帧间插值计算</strong></li></ol><h3 id="_2-3-操作指令映射-todo" tabindex="-1"><a class="header-anchor" href="#_2-3-操作指令映射-todo"><span>2.3 操作指令映射 (TODO)</span></a></h3><p>定义操作编码规范:</p><table><thead><tr><th>编码</th><th>含义</th><th>旋转角度</th></tr></thead><tbody><tr><td>F</td><td>前面顺时针</td><td>90°</td></tr><tr><td>F’</td><td>前面逆时针</td><td>-90°</td></tr><tr><td>U2</td><td>上面 180°</td><td>180°</td></tr></tbody></table><h2 id="_3-实现效果展示" tabindex="-1"><a class="header-anchor" href="#_3-实现效果展示"><span>3. 实现效果展示</span></a></h2><h2 id="_4-后续工作计划" tabindex="-1"><a class="header-anchor" href="#_4-后续工作计划"><span>4. 后续工作计划</span></a></h2><ol><li>完善操作指令解析模块</li><li>实现文件操作序列的导入/导出</li><li>添加碰撞检测优化动画效果</li><li>开发用户交互控制面板</li></ol>`,33)])])}const d=s(l,[["render",n]]),r=JSON.parse('{"path":"/PhD/course/2024-2025_Spring_Term/84100253-Computer_Aided_Geometry_Modeling/2025-04-11-07-%E7%AC%AC7%E6%AC%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%BF%9B%E5%B1%95%E6%8A%A5%E5%91%8A.html","title":"第 7 次大作业进展报告","lang":"en-US","frontmatter":{"date":"2025-04-11T08:05:00.000Z","modified":"2025-09-20T10:41:48.000Z","tags":["PhD/Course/Computer_Aided_Geometry_Modeling"],"title":"第 7 次大作业进展报告","description":"问题 请编写带有图形界面的普通三阶魔方模拟程序. 要求: 实现平移、放大、缩小和自适应大小的魔方展示功能. 请自定义编码表示魔方的各种可能操作, 每种编码表示其中 1 种操作. 实现打开文本文件的功能, 该文本文件由一系列编码组成, 对应魔方操作. 实现魔方操作功能: 可以交互实现每个操作, 也可以通过动画自动播放魔方的系列操作. 在操作或转动魔方时,...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第 7 次大作业进展报告\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-04-11T08:05:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"liblaf\\",\\"url\\":\\"https://github.com/liblaf\\"}]}"],["meta",{"property":"og:url","content":"https://hope.liblaf.me/PhD/course/2024-2025_Spring_Term/84100253-Computer_Aided_Geometry_Modeling/2025-04-11-07-%E7%AC%AC7%E6%AC%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E8%BF%9B%E5%B1%95%E6%8A%A5%E5%91%8A.html"}],["meta",{"property":"og:site_name","content":"liblaf"}],["meta",{"property":"og:title","content":"第 7 次大作业进展报告"}],["meta",{"property":"og:description","content":"问题 请编写带有图形界面的普通三阶魔方模拟程序. 要求: 实现平移、放大、缩小和自适应大小的魔方展示功能. 请自定义编码表示魔方的各种可能操作, 每种编码表示其中 1 种操作. 实现打开文本文件的功能, 该文本文件由一系列编码组成, 对应魔方操作. 实现魔方操作功能: 可以交互实现每个操作, 也可以通过动画自动播放魔方的系列操作. 在操作或转动魔方时,..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"PhD/Course/Computer_Aided_Geometry_Modeling"}],["meta",{"property":"article:published_time","content":"2025-04-11T08:05:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.59,"words":778},"filePathRelative":"PhD/course/2024-2025_Spring_Term/84100253-Computer_Aided_Geometry_Modeling/2025-04-11-07-第7次大作业进展报告.md","excerpt":"<h2>问题</h2>\\n<p>请编写带有图形界面的普通三阶魔方模拟程序.</p>\\n<p>要求:</p>\\n<ul>\\n<li>实现平移、放大、缩小和自适应大小的魔方展示功能.</li>\\n<li>请自定义编码表示魔方的各种可能操作, 每种编码表示其中 1 种操作.</li>\\n<li>实现打开文本文件的功能, 该文本文件由一系列编码组成, 对应魔方操作.</li>\\n<li>实现魔方操作功能: 可以交互实现每个操作, 也可以通过动画自动播放魔方的系列操作.</li>\\n<li>在操作或转动魔方时, 必须以动画的形式展示, 从而方便看清如何操作或转动.</li>\\n<li>可以保存魔方操作, 保存结果是由一系列编码组成文本文件.</li>\\n<li>编写文档详细介绍模拟算法与图形界面等内容.</li>\\n</ul>","autoDesc":true}');export{d as comp,r as data};
